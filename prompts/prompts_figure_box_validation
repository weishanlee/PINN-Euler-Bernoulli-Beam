# Figure Box Validation Guidelines

## Purpose
This document provides comprehensive guidelines for creating figures with boxes (workflow diagrams, architecture diagrams, flowcharts) while ensuring proper validation of box placement and text sizing.

## üõë MANDATORY Validation Workflow

**Every figure with boxes MUST follow this workflow:**

1. **Pre-Generation Planning** (Use checklist in `prompts_figure`)
2. **Initial Generation** (Create figure_v1.png with planned layout)
3. **Validation Check** (Run `box_overlap_checker.py` on figure_v1.png)
4. **Auto-Correction** (If validation fails, create figure_v2.png using `smart_box_layout.py`)
5. **Final Verification** (Re-run validation to confirm)
6. **Save Only After Validation Passes** (Never overwrite - always increment version)

**Kill Switch Triggers:**
- ‚ùå Box overlap validation fails
- ‚ùå Text extends beyond box boundaries  
- ‚ùå Font size < 10pt for box labels (increased from 8pt)
- ‚ùå Any standalone text overlaps with boxes
- ‚ùå Section headers overlap with any diagram elements
- ‚ùå Vertical spacing between layers < 1.5 units
- ‚ùå Boxes positioned outside canvas bounds
- ‚ùå Total overlap area > 0
- ‚ùå Validation fails after 3 attempts

## Core Validation Rules

### 1. Box-to-Box Overlap Prevention
**Requirement**: No two boxes should overlap with each other.

**Implementation**:
```python
def check_box_overlap(box1, box2):
    x1_min, x1_max = box1['x'], box1['x'] + box1['width']
    y1_min, y1_max = box1['y'], box1['y'] + box1['height']
    x2_min, x2_max = box2['x'], box2['x'] + box2['width']
    y2_min, y2_max = box2['y'], box2['y'] + box2['height']
    
    x_overlap = not (x1_max <= x2_min or x2_max <= x1_min)
    y_overlap = not (y1_max <= y2_min or y2_max <= y1_min)
    
    return x_overlap and y_overlap
```

**Best Practices**:
- Maintain minimum spacing of 0.2 units between boxes
- Use grid-based layouts for consistent spacing
- Apply automatic repositioning when overlaps detected

### 2. Text-to-Box Overlap Prevention
**Requirement**: Standalone text must not overlap with any boxes.

**Implementation**:
- Calculate text bounding boxes using matplotlib renderer
- Check intersection with all existing boxes
- Adjust text position or use leader lines if needed

**Best Practices**:
- Position labels above or below boxes
- Use consistent text alignment (center, left, right)
- Add background to text for better visibility

### 3. Text-in-Box Fit Validation
**Requirement**: Text inside boxes must fit properly with appropriate font size.

**Validation Criteria**:
- Text width ‚â§ box_width √ó 0.8 (80% to allow padding)
- Text height ‚â§ box_height √ó 0.8
- Minimum font size: 10pt (increased from 8pt for better readability)
- Maximum font size: 14pt

**Automatic Adjustment**:
```python
if text_width > box_inner_width or text_height > box_inner_height:
    width_ratio = box_inner_width / text_width
    height_ratio = box_inner_height / text_height
    scale_factor = min(width_ratio, height_ratio) * 0.9
    new_fontsize = current_fontsize * scale_factor
```

## Workflow for Figure Generation

### Step 1: Planning
1. Determine number of boxes needed
2. Estimate text content for each box
3. Choose appropriate figure dimensions
4. Select color scheme from `prompts_colorSet`

### Step 2: Initial Layout
1. Create rough positioning of boxes
2. Use grid alignment for consistency
3. Group related boxes together
4. Leave space for arrows/connectors

### Step 3: Validation
1. Run box overlap validation
2. Check text fit in all boxes
3. Verify standalone text doesn't overlap
4. Adjust positions/sizes as needed

### Step 4: Optimization
1. Apply smart layout algorithms
2. Optimize spacing between elements
3. Ensure visual balance
4. Add connectors and annotations

## Using the Validation Tools

### box_overlap_checker.py
Use for validating existing layouts:

```python
from utilityScripts.box_overlap_checker import BoxValidator

# Create validator
validator = BoxValidator(figsize=(12, 8))

# Add boxes
validator.add_box(1, 1, 3, 2, "Process A")
validator.add_box(5, 1, 3, 2, "Process B")
validator.add_box(9, 1, 3, 2, "Process C")

# Validate
results = validator.validate_all()

# Check results
if results['box_overlaps']:
    print("WARNING: Box overlaps detected!")
    for overlap in results['box_overlaps']:
        print(f"Box {overlap['box1_index']} overlaps with {overlap['box2_index']}")

# Visualize with validation
fig, ax, validation = validator.visualize_with_validation()
plt.savefig('output/figures/validated_diagram.png', dpi=300)
```

**Extended Example with Complete Validation:**
```python
# For validation of existing layouts
from box_overlap_checker import BoxValidator
validator = BoxValidator()
validator.add_box(x, y, width, height, label)
results = validator.validate_all()

# For automatic smart layouts
from smart_box_layout import SmartBoxLayout
layout = SmartBoxLayout()
layout.add_box(x, y, width, height, label)
layout.render("output_path.png")
```

### smart_box_layout.py
Use for automatic layout generation:

```python
from utilityScripts.smart_box_layout import SmartBoxLayout, SmartBox

# Create layout manager
layout = SmartBoxLayout(figsize=(14, 10), xlim=(0, 14), ylim=(0, 10))

# Add boxes - overlaps will be automatically resolved
layout.add_box(2, 2, 3, 2, "Data\nCollection", color='lightblue')
layout.add_box(3, 3, 3, 2, "Data\nProcessing", color='lightgreen')  # Would overlap!
layout.add_box(6, 2, 3, 2, "Analysis", color='lightyellow')

# Optimize and render
layout.optimize_layout()
fig, ax = layout.render(title="Workflow Diagram", 
                       output_path="output/figures/smart_workflow.png")
```

## Common Figure Types

### 1. Linear Workflow
- Boxes arranged horizontally or vertically
- Equal spacing between stages
- Arrows showing flow direction

### 2. Hierarchical Diagram
- Tree-like structure
- Parent boxes above children
- Consistent level alignment

### 3. Network Diagram
- Central node with connections
- Radial or force-directed layout
- Avoid crossing connections

### 4. Matrix Layout
- Grid arrangement of boxes
- Consistent rows and columns
- Clear labeling of axes

## Color Guidelines

Use colors from `prompts_colorSet`:
- **Primary boxes**: Use main theme colors
- **Secondary boxes**: Use lighter shades
- **Highlight boxes**: Use contrasting colors
- **Error/Warning boxes**: Use red/orange tones

## Error Handling

### When Overlaps Cannot Be Resolved:
1. Increase figure size
2. Reduce box sizes
3. Use multi-line text
4. Consider splitting into multiple figures

### When Text Doesn't Fit:
1. Use abbreviations
2. Split into multiple lines
3. Reduce font size (minimum 10pt)
4. Increase box size if possible

## Quality Checklist

Before finalizing any figure with boxes:
- [ ] No box overlaps detected
- [ ] All text fits within boxes
- [ ] Font sizes are ‚â•10pt (minimum requirement)
- [ ] Minimum spacing maintained (30% horizontal, 40% vertical)
- [ ] Colors follow guidelines from `prompts_colorSet`
- [ ] Labels are readable and properly positioned
- [ ] Arrows/connectors don't overlap boxes
- [ ] Figure has appropriate title
- [ ] Export at 300 DPI minimum
- [ ] Canvas has 10% edge padding
- [ ] Text padding inside boxes is 15% of box dimensions

## Enhanced Validation Checklist for Architecture Diagrams

**MANDATORY** for all architecture and workflow diagrams:
- [ ] Pre-generation planning completed (counted components, calculated canvas size)
- [ ] Component dimensions calculated based on text content
- [ ] Spacing verified: 30% horizontal, 40% vertical between components
- [ ] All font sizes between 10-14pt (no exceptions)
- [ ] Text-box fit validated with smart_box_layout.py
- [ ] Connection lines have 15% clearance from box edges
- [ ] No dangling labels without clear purpose
- [ ] Validation passed with box_overlap_checker.py
- [ ] If validation failed, regenerated with smart layout
- [ ] Final validation confirmed zero overlaps

### Architecture Diagram Specific Spacing Rules

**Component Sizing Guidelines:**
```python
# Calculate component dimensions based on text
def calculate_box_size(text, base_width=3, base_height=1.5):
    lines = text.split('\n')
    max_chars = max(len(line) for line in lines)
    
    # Width: 0.15 units per character, minimum base_width
    width = max(base_width, max_chars * 0.15)
    
    # Height: 0.5 units per line, minimum base_height
    height = max(base_height, len(lines) * 0.5 + 0.5)  # +0.5 for padding
    
    return width, height
```

**Layout Planning:**
```python
# Pre-calculate canvas size
def calculate_canvas_size(num_components, layout_type='grid'):
    if layout_type == 'grid':
        cols = math.ceil(math.sqrt(num_components))
        rows = math.ceil(num_components / cols)
        # 4 units per component + 30% spacing
        width = cols * 4 * 1.3 + 2  # +2 for margins
        height = rows * 2 * 1.4 + 2  # +2 for margins
    elif layout_type == 'hierarchical':
        # Assume max 4 components per layer
        layers = math.ceil(num_components / 4)
        width = 4 * 4 * 1.3 + 2
        height = layers * 2 * 1.4 + 2
    return width, height
```

## Example: Complete Workflow Diagram

```python
# Complete example with validation
from utilityScripts.smart_box_layout import SmartBoxLayout
import matplotlib.pyplot as plt

# Create layout
layout = SmartBoxLayout(figsize=(16, 10))

# Define workflow stages
stages = [
    ("Data Input", 2, 8, 3, 1.5, 'lightblue'),
    ("Validation", 6, 8, 3, 1.5, 'lightgreen'),
    ("Processing", 10, 8, 3, 1.5, 'lightyellow'),
    ("Model Training", 4, 5, 3, 1.5, 'lightcoral'),
    ("Evaluation", 8, 5, 3, 1.5, 'lightpink'),
    ("Deployment", 6, 2, 3, 1.5, 'palegreen'),
]

# Add all boxes
for label, x, y, w, h, color in stages:
    layout.add_box(x, y, w, h, label, color=color)

# Optimize layout
layout.optimize_layout()

# Render with validation (always use version numbers)
fig, ax = layout.render(title="Machine Learning Pipeline",
                       output_path="output/figures/ml_pipeline_v1.png")

# Add arrows (after layout is finalized)
arrow_props = dict(arrowstyle='->', lw=2, color='gray')
# Add connections between boxes...

plt.tight_layout()
plt.savefig("output/figures/ml_pipeline_v1.png", dpi=300, bbox_inches='tight')
```

## Integration with Paper Generation

When generating figures for papers:
1. Always validate layouts before including in paper
2. Save both the Python script and output image with version numbers
3. Document any manual adjustments made
4. Include figure generation code in appendix
5. Reference specific box positions in text using coordinates

### MANDATORY: Version Naming for Figures
- **First figure**: `figure_name_v1.png`, `figure_script_v1.py`
- **Updates**: `figure_name_v2.png`, `figure_script_v2.py`
- **NEVER use**: `figure_final.png`, `diagram_revised.png`
- **Helper scripts**: `layout_helper_v1.py`

## üõë Validation Commands Reference

### Standard Validation Workflow (with Version Control)
```bash
# Navigate to output directory
cd output

# Step 1: Validate existing figure (v1)
~/.venv/ml_31123121/bin/python ../utilityScripts/box_overlap_checker.py figures/my_diagram_v1.png

# Step 2: If validation fails, regenerate as v2
~/.venv/ml_31123121/bin/python ../utilityScripts/smart_box_layout.py figures/my_diagram_v1.png
# Output will be saved as my_diagram_v2.png

# Step 3: Re-validate new version
~/.venv/ml_31123121/bin/python ../utilityScripts/box_overlap_checker.py figures/my_diagram_v2.png

# Step 4: Generate validation report (with version)
~/.venv/ml_31123121/bin/python ../utilityScripts/box_overlap_checker.py figures/my_diagram_v2.png --report > figures/validation_report_v1.txt
```

### Batch Validation (for versioned figures)
```bash
# Validate all versioned figures with boxes
for fig in figures/*diagram*_v*.png figures/*workflow*_v*.png figures/*architecture*_v*.png; do
    echo "Validating $fig..."
    ~/.venv/ml_31123121/bin/python ../utilityScripts/box_overlap_checker.py "$fig"
done

# Track validation results by version
echo "Validation completed on $(date)" >> figures/validation_log_v1.txt
```

### Emergency Recovery
If validation keeps failing:
1. Reduce number of boxes
2. Use hierarchical layout instead of flat
3. Split into multiple smaller diagrams
4. Request user guidance for complex layouts

## Extended Implementation Details from CLAUDE.md

### Figure Generation Kill Switch Rules

**STOP and regenerate if ANY of these conditions occur:**
- ‚ùå Box overlap validation fails
- ‚ùå Text extends beyond box boundaries  
- ‚ùå Font size < 10pt for box labels (increased from 8pt)
- ‚ùå Any standalone text overlaps with boxes
- ‚ùå Section headers overlap with any diagram elements
- ‚ùå Vertical spacing between layers < 1.5 units
- ‚ùå Boxes positioned outside canvas bounds
- ‚ùå Total overlap area > 0

**When kill switch triggered:**
1. Log the specific validation failure
2. Attempt automatic correction with `smart_box_layout.py`
3. If auto-correction fails, create simplified layout with fewer elements
4. Present alternative layouts to user for selection

### Implementation Tools from CLAUDE.md

**Two utility scripts are available for box validation:**

1. **`utilityScripts/box_overlap_checker.py`**
   - Validates existing layouts for overlaps
   - Provides detailed validation reports
   - Recommends font size adjustments
   - Visualizes problematic overlaps in red

2. **`utilityScripts/smart_box_layout.py`**
   - Automatically adjusts box positions to avoid overlaps
   - Smart font sizing to fit text within boxes
   - Spiral search algorithm for optimal positioning
   - Layout optimization for even spacing

### Complete box_overlap_checker.py Implementation

```python
#!/usr/bin/env python3
"""Box overlap validation tool for diagrams"""
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from matplotlib.patches import FancyBboxPatch
import numpy as np

class BoxValidator:
    def __init__(self, figsize=(12, 8)):
        self.boxes = []
        self.texts = []
        self.figsize = figsize
        self.validation_results = {
            'box_overlaps': [],
            'text_overlaps': [],
            'text_fit_issues': [],
            'font_size_issues': []
        }
    
    def add_box(self, x, y, width, height, label, fontsize=12):
        """Add a box to validate"""
        self.boxes.append({
            'x': x, 'y': y, 'width': width, 'height': height,
            'label': label, 'fontsize': fontsize
        })
    
    def add_text(self, x, y, text, fontsize=12):
        """Add standalone text to validate"""
        self.texts.append({
            'x': x, 'y': y, 'text': text, 'fontsize': fontsize
        })
    
    def check_box_overlap(self, box1, box2):
        """Check if two boxes overlap"""
        x1_min, x1_max = box1['x'], box1['x'] + box1['width']
        y1_min, y1_max = box1['y'], box1['y'] + box1['height']
        x2_min, x2_max = box2['x'], box2['x'] + box2['width']
        y2_min, y2_max = box2['y'], box2['y'] + box2['height']
        
        x_overlap = not (x1_max <= x2_min or x2_max <= x1_min)
        y_overlap = not (y1_max <= y2_min or y2_max <= y1_min)
        
        if x_overlap and y_overlap:
            # Calculate overlap area
            overlap_x = min(x1_max, x2_max) - max(x1_min, x2_min)
            overlap_y = min(y1_max, y2_max) - max(y1_min, y2_min)
            overlap_area = overlap_x * overlap_y
            return True, overlap_area
        return False, 0
    
    def check_text_fit(self, box):
        """Check if text fits within box"""
        # Estimate text dimensions (simplified)
        lines = box['label'].split('\n')
        max_chars = max(len(line) for line in lines)
        
        # Rough estimation: 0.1 units per character width
        text_width = max_chars * 0.1 * (box['fontsize'] / 12)
        text_height = len(lines) * 0.15 * (box['fontsize'] / 12)
        
        # Check with 80% margin
        fits_width = text_width <= box['width'] * 0.8
        fits_height = text_height <= box['height'] * 0.8
        
        return fits_width and fits_height, text_width, text_height
    
    def validate_all(self):
        """Run all validation checks"""
        # Reset results
        self.validation_results = {
            'box_overlaps': [],
            'text_overlaps': [],
            'text_fit_issues': [],
            'font_size_issues': [],
            'spacing_issues': []
        }
        
        # Check box-to-box overlaps
        for i, box1 in enumerate(self.boxes):
            for j, box2 in enumerate(self.boxes[i+1:], i+1):
                overlaps, area = self.check_box_overlap(box1, box2)
                if overlaps:
                    self.validation_results['box_overlaps'].append({
                        'box1_index': i,
                        'box2_index': j,
                        'overlap_area': area
                    })
        
        # Check text fit and font sizes
        for i, box in enumerate(self.boxes):
            fits, text_w, text_h = self.check_text_fit(box)
            if not fits:
                self.validation_results['text_fit_issues'].append({
                    'box_index': i,
                    'text_width': text_w,
                    'text_height': text_h,
                    'box_width': box['width'],
                    'box_height': box['height']
                })
            
            if box['fontsize'] < 10:
                self.validation_results['font_size_issues'].append({
                    'box_index': i,
                    'fontsize': box['fontsize'],
                    'minimum_required': 10
                })
        
        # Check minimum spacing
        for i, box1 in enumerate(self.boxes):
            for j, box2 in enumerate(self.boxes[i+1:], i+1):
                # Calculate spacing
                x_gap = abs(box1['x'] + box1['width'] - box2['x'])
                y_gap = abs(box1['y'] + box1['height'] - box2['y'])
                
                min_x_spacing = max(box1['width'], box2['width']) * 0.3
                min_y_spacing = max(box1['height'], box2['height']) * 0.4
                
                if x_gap < min_x_spacing or y_gap < min_y_spacing:
                    self.validation_results['spacing_issues'].append({
                        'box1_index': i,
                        'box2_index': j,
                        'x_gap': x_gap,
                        'y_gap': y_gap,
                        'required_x': min_x_spacing,
                        'required_y': min_y_spacing
                    })
        
        return self.validation_results
    
    def visualize_with_validation(self):
        """Visualize boxes with validation highlights"""
        fig, ax = plt.subplots(1, 1, figsize=self.figsize)
        
        # Draw boxes
        for i, box in enumerate(self.boxes):
            # Check if this box has issues
            has_overlap = any(o['box1_index'] == i or o['box2_index'] == i 
                            for o in self.validation_results['box_overlaps'])
            has_text_issue = any(t['box_index'] == i 
                               for t in self.validation_results['text_fit_issues'])
            has_font_issue = any(f['box_index'] == i 
                               for f in self.validation_results['font_size_issues'])
            
            # Choose color based on issues
            if has_overlap:
                color = 'red'
                alpha = 0.3
            elif has_text_issue or has_font_issue:
                color = 'orange'
                alpha = 0.3
            else:
                color = 'lightgreen'
                alpha = 0.3
            
            # Draw box
            rect = FancyBboxPatch(
                (box['x'], box['y']), box['width'], box['height'],
                boxstyle="round,pad=0.1",
                facecolor=color, edgecolor='black', alpha=alpha
            )
            ax.add_patch(rect)
            
            # Add label
            ax.text(box['x'] + box['width']/2, box['y'] + box['height']/2,
                   box['label'], ha='center', va='center',
                   fontsize=box['fontsize'], weight='bold')
        
        # Add validation summary
        summary = self.generate_summary()
        ax.text(0.02, 0.98, summary, transform=ax.transAxes,
               verticalalignment='top', fontsize=10,
               bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))
        
        ax.set_xlim(0, 14)
        ax.set_ylim(0, 10)
        ax.set_aspect('equal')
        ax.grid(True, alpha=0.3)
        ax.set_title('Box Layout Validation', fontsize=16)
        
        return fig, ax, self.validation_results
    
    def generate_summary(self):
        """Generate validation summary text"""
        issues = []
        if self.validation_results['box_overlaps']:
            issues.append(f"‚ùå {len(self.validation_results['box_overlaps'])} box overlaps")
        if self.validation_results['text_fit_issues']:
            issues.append(f"‚ö†Ô∏è  {len(self.validation_results['text_fit_issues'])} text fit issues")
        if self.validation_results['font_size_issues']:
            issues.append(f"‚ö†Ô∏è  {len(self.validation_results['font_size_issues'])} font size issues")
        if self.validation_results['spacing_issues']:
            issues.append(f"‚ö†Ô∏è  {len(self.validation_results['spacing_issues'])} spacing issues")
        
        if not issues:
            return "‚úÖ All validation checks passed!"
        else:
            return "Validation Issues:\n" + "\n".join(issues)
```

### Complete smart_box_layout.py Implementation

```python
#!/usr/bin/env python3
"""Smart box layout generator with automatic overlap resolution"""
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np
from typing import List, Tuple, Dict

class SmartBox:
    def __init__(self, x, y, width, height, label, color='lightblue', fontsize=12):
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.label = label
        self.color = color
        self.fontsize = fontsize
        self.original_pos = (x, y)
    
    def overlaps_with(self, other):
        """Check if this box overlaps with another"""
        x_overlap = not (self.x + self.width <= other.x or 
                        other.x + other.width <= self.x)
        y_overlap = not (self.y + self.height <= other.y or 
                        other.y + other.height <= self.y)
        return x_overlap and y_overlap
    
    def distance_to(self, other):
        """Calculate center-to-center distance"""
        cx1 = self.x + self.width / 2
        cy1 = self.y + self.height / 2
        cx2 = other.x + other.width / 2
        cy2 = other.y + other.height / 2
        return np.sqrt((cx2 - cx1)**2 + (cy2 - cy1)**2)

class SmartBoxLayout:
    def __init__(self, figsize=(14, 10), xlim=(0, 14), ylim=(0, 10)):
        self.boxes = []
        self.figsize = figsize
        self.xlim = xlim
        self.ylim = ylim
        self.min_spacing = 0.3  # Minimum 30% spacing
    
    def add_box(self, x, y, width, height, label, color='lightblue', fontsize=12):
        """Add a box and automatically resolve overlaps"""
        new_box = SmartBox(x, y, width, height, label, color, fontsize)
        
        # Auto-adjust font size if text doesn't fit
        new_box.fontsize = self.calculate_optimal_fontsize(new_box)
        
        # Check for overlaps and resolve
        if self.boxes:
            new_box = self.resolve_overlaps(new_box)
        
        self.boxes.append(new_box)
    
    def calculate_optimal_fontsize(self, box):
        """Calculate optimal font size for text to fit in box"""
        lines = box.label.split('\n')
        max_chars = max(len(line) for line in lines)
        
        # Estimate required font size
        width_constraint = (box.width * 0.8) / (max_chars * 0.1)
        height_constraint = (box.height * 0.8) / (len(lines) * 0.15)
        
        optimal_size = min(width_constraint * 12, height_constraint * 12, 14)
        return max(10, optimal_size)  # Minimum 10pt
    
    def resolve_overlaps(self, new_box):
        """Resolve overlaps using spiral search"""
        # Check if there are any overlaps
        overlapping = [b for b in self.boxes if new_box.overlaps_with(b)]
        
        if not overlapping:
            return new_box
        
        # Spiral search for new position
        angle_step = np.pi / 8
        radius_step = 0.5
        max_attempts = 100
        
        for attempt in range(max_attempts):
            angle = attempt * angle_step
            radius = (attempt // 16) * radius_step
            
            # Calculate new position
            dx = radius * np.cos(angle)
            dy = radius * np.sin(angle)
            
            test_box = SmartBox(
                new_box.original_pos[0] + dx,
                new_box.original_pos[1] + dy,
                new_box.width, new_box.height,
                new_box.label, new_box.color, new_box.fontsize
            )
            
            # Check boundaries
            if (test_box.x < self.xlim[0] or 
                test_box.x + test_box.width > self.xlim[1] or
                test_box.y < self.ylim[0] or 
                test_box.y + test_box.height > self.ylim[1]):
                continue
            
            # Check overlaps
            if not any(test_box.overlaps_with(b) for b in self.boxes):
                # Check minimum spacing
                if self.check_minimum_spacing(test_box):
                    return test_box
        
        # If no position found, return original (will show as overlap)
        print(f"Warning: Could not resolve overlap for box '{new_box.label}'")
        return new_box
    
    def check_minimum_spacing(self, test_box):
        """Check if minimum spacing requirements are met"""
        for box in self.boxes:
            x_gap = min(
                abs(test_box.x - (box.x + box.width)),
                abs(box.x - (test_box.x + test_box.width))
            )
            y_gap = min(
                abs(test_box.y - (box.y + box.height)),
                abs(box.y - (test_box.y + test_box.height))
            )
            
            min_x = max(test_box.width, box.width) * self.min_spacing
            min_y = max(test_box.height, box.height) * 0.4
            
            if x_gap < min_x and y_gap < min_y:
                return False
        return True
    
    def optimize_layout(self):
        """Optimize layout for better visual balance"""
        # Group boxes by proximity
        # Align boxes on grid where possible
        # Balance white space
        pass  # Advanced optimization can be added here
    
    def render(self, title="Smart Box Layout", output_path=None):
        """Render the layout"""
        fig, ax = plt.subplots(1, 1, figsize=self.figsize)
        
        # Draw boxes
        for box in self.boxes:
            # Draw box with rounded corners
            rect = patches.FancyBboxPatch(
                (box.x, box.y), box.width, box.height,
                boxstyle="round,pad=0.1",
                facecolor=box.color,
                edgecolor='black',
                linewidth=2
            )
            ax.add_patch(rect)
            
            # Add text
            ax.text(
                box.x + box.width/2,
                box.y + box.height/2,
                box.label,
                ha='center', va='center',
                fontsize=box.fontsize,
                weight='bold'
            )
        
        # Set limits and style
        ax.set_xlim(self.xlim)
        ax.set_ylim(self.ylim)
        ax.set_aspect('equal')
        ax.grid(True, alpha=0.3)
        ax.set_title(title, fontsize=16, weight='bold')
        
        # Remove axis labels for cleaner look
        ax.set_xticks([])
        ax.set_yticks([])
        
        plt.tight_layout()
        
        if output_path:
            plt.savefig(output_path, dpi=300, bbox_inches='tight')
            print(f"Figure saved to: {output_path}")
        
        return fig, ax
```

### Architecture Diagram Specific Rules from CLAUDE.md

**MANDATORY** for all architecture and workflow diagrams:

1. **Spacing Requirements**
   - Horizontal spacing between components: minimum 30% of component width
   - Vertical spacing between layers: minimum 40% of component height
   - Edge padding: minimum 10% of canvas dimensions
   - Connection lines must have 15% clearance from box edges

2. **Component Sizing Guidelines** - Calculate dimensions based on text content
3. **Text Requirements** - Font sizes between 10-14pt with proper padding
4. **Layout Planning** - Pre-calculate canvas size for optimal spacing

5. **Validation Checklist**
   - [ ] All boxes have ‚â•30% horizontal spacing
   - [ ] All layers have ‚â•40% vertical spacing
   - [ ] Font sizes are between 10-14pt
   - [ ] No text extends beyond box boundaries
   - [ ] Connection lines don't overlap with boxes
   - [ ] Canvas has 10% edge padding

### Internal Process Reminders from CLAUDE.md

**For figures with boxes specifically:**
- "Did I run box_overlap_checker.py?"
- "Did validation pass without overlaps?"
- "Are all font sizes ‚â• 8pt?" (Note: Now updated to ‚â•10pt)

These validation steps are CRITICAL and must be completed before saving any figure.